# Задание №1. ArrayUtils

## Задачи

Вам необходимо реализовать несколько статических функций, находящихся в классе `ArrayUtils`.

Эти функции призваны упростить работу с массивами, у которых в `Java` довольно мало собственных
методов.

Задачи условно разделены на три раздела: 

1. Задания на печать массивов (`printArray`). 
   
   В них предлагается поупражняться в работе с массивами, а также воспользоваться 
   `System.out.print` и `System.out.println` для печати. 
2. Задания на Merge Sort (`subArray`, `chunked`, `mergeSortedArrays`, `sorted`). 
3. Задачи на мутацию массивов (`reverseRange`, `rotate`).

Суммарная стоимость задач - 10 баллов. Стоимость каждой отдельной
задачи указана в её javadoc-е (в комментарии над функцией).

**Ограничения**: 
- можно пользоваться статическими функциями из классов `System` и `Math`
   - мы рекомендуем бегло ознакомиться с документацией на эти классы, это можно сделать прямо внутри Intellij IDEA или на сайте Oracle
- нельзя пользоваться статическими функциями из класса `Arrays` 
- нельзя использовать классы коллекций

Про остальные функции из стандартной библиотеки уточняйте у команды проверяющих. 

**ВАЖНО**: старайтесь подойти к работе аккуратно и переиспользовать уже написанные функции, где это
возможно. 

## Как сдавать

При создании вашего репозитория будет автоматически создан Pull Request для проверки (#1).

Вы должны закоммитить своё решение в ветку `main` (это ветка вашего репозитория по-умолчанию), и
эти коммиты автоматически добавятся в Pull Request. 

Когда вы будете готовы сдать решение на первую проверку, добавьте к вашему пулл-реквесту лейбл `ready-for-review`. Это можно сделать в правой части страницы с пулл-реквестом.

Пожалуйста, не забудьте это сделать, иначе мы не сможем оперативно найти вашу работу и проверить её вовремя.

Если у вас возникают проблемы на каком-то из этих шагов, пожалуйста, сообщите об этом команде проверяющих. Чем
быстрее вы это сделаете, тем быстрее мы поможем вам.

## Дополнительные материалы

Здесь собраны данные, которые могут быть полезны при выполнении данного задания.

### Статические функции

**tl;dr**: Используйте модификатор `static`, чтобы пометить функцию в классе, как статическую.

Статические функции можно использовать как обычные глобальные функции.

<details>
<summary>Пример</summary>

```java
package com.library.utils;

public class MathUtils {

  public static int multiply(int lhs, int rhs) {
    return lhs * rhs;
  }
}
```

```java
package org.company.usage;

import com.library.utils.MathUtils;
import com.library.utils.MathUtils.multiply;

public class Main {

  public static void main(String[] args) {

    // это вызов через полное имя
    int value1 = com.library.utils.MathUtils.multiply(1, 2);

    // это вызов через имя класса
    // предпочтительный способ в 99% случаев
    // (смотри import com.library.utils.MathUtils;)
    int value2 = MathUtils.multiply(1, 2);

    // это вызов через полностью импортированную функцию
    // (смотри import com.library.utils.MathUtils.multiply;)
    int value3 = multiply(1, 2);

    // во всех трех случаях вызывалась одна и та же функция

    System.out.println(value1);
    System.out.println(value2);
    System.out.println(value3);
  }
}
```

</details>

<details>
<summary>Подробнее про классы и статические функции</summary>

В `Java` существует понятие класса. Класс – настолько фундаментальная конструкция, что без неё
нельзя написать даже точку входа в программу – метод `main`.

Классы используются, чтобы описывать и конструировать объекты с определенными полями и методами.
Однако иногда бывает удобным вызывать методы без какого-то конкретного объекта – например, тот же
самый `main`, или вспомогательные методы, которые не привязаны к состоянию какого-то конкретного
объекта.

Для этого в `Java` есть модификатор `static`, которым могут быть помечены методы классов
(и не только). Эти методы становятся статическими. Статические методы привязаны к классу и теперь их
можно вызывать просто так, без объекта. В них, в отличие от обычных ("динамических"/нестатических)
методов, не передается ссылка на текущий объект `this`, поэтому внутри статических методов нет
доступа к нестатическим методам и нестатическим полям.

Обычно рекомендуется делать методы статическими, когда они никак не используют состояние объекта.

Часто, в больших проектах есть необходимость создавать вспомогательные функции, которые относятся к
одной логической сущности. Поскольку в `Java` нельзя объявлять top-level функции, а только методы,
то часто создают "утилитные" классы, из которых явно запрещено создавать объекты. Такие классы
содержат набор статических методов. Пример такого класса - наш `ArrayUtils`, который содержит
вспомогательные статические методы для работы с массивами.
</details>

### Циклы for и while

**tl;dr**: Используйте конструкции `for (int i = 0; i < ...; i++)`
и `while (condition) {...}` для итерации.

<details>
<summary>Подробнее про циклы</summary>
Цикл является простейшим инструментом для уменьшения дублирования кода: он позволяет выполнить
какое-либо действие несколько раз.

В `Java` есть `for` и `while` циклы.

Примеры использования цикла `for`:

```java
class ForExample {

  void hardAction(int index, String value) {}

  void simpleAction(String value) {}

  void demonstrate(String[] array) {

    // Итерация по массиву с помощью индекса
    for (int i = 0; i < array.length; i++) {
      hardAction(i, array[i]);
    }

    // Итерация по массиву в обратном порядке с шагом в 2
    for (int i = array.length - 1; i >= 0; i -= 2) {
      hardAction(i, array[i]);
    }

    // Enhanced For Loop (for-each)
    // Работает на массивах и на объектах типа `java.lang.Iterable` (про это расскажут позднее)
    // Если вам нужно перебрать все элементы массива в обычном порядке без индекса, используйте его
    for (String i : array) {
      simpleAction(i);
    }
  }
}
```

N.B.: В `Java` в циклах принято использовать постфиксный инкремент, т.е. `i++`.

Примеры использования цикла `while`:

```java
class WhileExample {

  void demonstrate(int N) {
    int current = 1;

    // условие проверяется при входе в цикл и на каждой новой итерации
    while (current <= N) {
      current *= 2;
    }

    do {
      current /= 2;
    } while (current > 0);
    // условие проверяется в конце каждой итерации; при входе в цикл не проверяется

    // принятый в Java способ создания бесконечного цикла
    current = 1;
    while (true) {

      if (current % 31 == 0) {
        break; // вызывает выход из цикла
      } else {
        current++;
      }

    }
  }
}
```

</details>

### Простая обработка ошибок

**tl;dr**: Используйте следующую конструкцию для валидации входных параметров, чтобы проверить, что условие `condition` выполняется.
```java
if (condition) {
  throw new IllegalArgumentException("message");    
}
```

Для часто требующихся проверок существуют следующие функции:
* [Objects.checkIndex](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Objects.html#checkIndex(long,long)) позволяет проверить, попадает ли индекс в заданные границы  
* [Objects.requireNonNull](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Objects.html#requireNonNull(T,java.lang.String))) позволяет обозначить запрет значения `null`

Эти функции выполнят проверку и сами выбросят исключение, если необходимое условие не выполняется.
Обратите внимание и на другие функции в классе [Objects](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Objects.html), возможно они окажутся вам полезны в этой и следующих задачах.

<details>
<summary>Подробнее про исключения</summary>

Допустим, что вы пишете функцию `double sqrt(double value)`, которая должна вычислять квадратный
корень из `value`:

```java
class MathUtils {

  public static double sqrt(double value) {
    ... // some computation
  }
}
```

Как известно, функция квадратного корня не может быть вычислена при отрицательных
значениях `value` (если мы хотим получить вещественный ответ). Другими словами, отрицательные числа
являются недопустимыми аргументами для функции `sqrt`.

Мы предлагаем воспользоваться механизмом исключений языка `Java`, чтобы прекратить
выполнение функции, если какое-то условие не выполнилось.

В случае с `sqrt` это будет выглядеть вот так:

```java
class MathUtils {

  public static double sqrt(double value) {
    // исключение без сообщения
    if (value < 0) {
      throw new IllegalArgumentException();
    }
    // или
    // исключение с сообщением, более предпочтительно включать информацию, которая поможет в отладке
    if (value < 0) {
      throw new IllegalArgumentException("value should be non-negative, but was " + value + " instead");
    }
    
    ... // some computation
  }
}
```

Мы используем конструкцию `"value should be non-negative, but was " + value + " instead" `
для создания информативного сообщения об ошибке, это называется конкатенацией строк.

Далее мы создаем объект класса исключения выражением `new IllegalArgumentException("message")` и используем оператор `throw <exception>`, чтобы выбросить исключение.

Будучи брошенным, исключение прерывает выполнение потока инструкций и летит наверх по стеку вызовов,
пока не достигнет подходящего блока `catch`. Если же ни один пользовательский `catch` не отработал,
то исключение будет поймано JVM, о чем будет напечатано в поток вывода stderr, после чего программа
(с некоторыми оговорками) завершится. Более подробно тема исключений будет рассмотрена позднее.

Хорошей практикой написания кода является валидация параметров в начале и быстрый выход из функции, оставляя основную логику без дополнительной вложенности. 

Пример кода с лишней вложенностью, от которой легко избавиться:
```java
class MathUtils {

  public static double sqrt(double value) {
    if (value >= 0) {
      // получили лишнюю вложенность для основного кода, которая может усложнять прочтение кода
      ... // some computation
    } else {
      throw new IllegalArgumentException("value should be non-negative, but was " + value + " instead");
    }
  }
}
```


</details>

### Обработка null

**tl;dr**: Если в вашу функцию передают `null`, вы должны сообщить об этом как об ошибке (в рамках
текущей домашней работы).

<details>
<summary>Подробнее про обработку `null` в `Java`</summary>

`null` является значением, которое может быть присвоено в любую переменную ссылочного типа (
например, `String`, `int[]`, `int[][]`).

Вызов метода на `null` приводит к выбросу знаменитого `NullPointerException`, или сокращенно `NPE`.

```java
class NPEExample {

  void stringRefExample() {
    String reference = null;

    // все хорошо, напечатает 'null'
    System.out.println(reference);

    // NPE, потому что reference == null, нельзя вызвать length
    System.out.println(reference.length());
  }

  void arrayRefExample() {
    int[] array = null;
    System.out.println(array[0]); // NPE, потому что array == null
  }
}
```

То, что `Java` выкидывает эту ошибку, является плюсом – это позволяет предотвратить дальнейшую
работу программы с несуществующим объектом. Однако сам по себе `NPE` является
**очень малоинформативным** - он лишь покажет строчку, где случилось исключение, и стек вызовов в
этот момент.

```java
class NPEExample {

  void printElements(int[] left, int[] right) {

    // Если отсюда выпадет NPE, то как узнать, какой из параметров имел значение `null`?
    System.out.println(left[0], right[0]);
  }
}
```

Java не имеет никаких встроенных механизмов для предотвращения распространения `null` в вашем коде.
По этой причине программы, которые много используют null и не слишком строго к нему относятся,
становится сложнее понимать - нужно постоянно держать в голове, что может быть `null`, а что нет.

В связи с этим мы даем две рекомендации:

1. Для упрощения вашего кода старайтесь минимизировать использование `null` в ваших программах.
2. Если для аргумента вашей функции значение `null` недопустимо, постарайтесь
   (насколько это возможно) проверить это в начале функции и выбросить исключение с сообщением об
   ошибке, если он все-таки равен `null`.

N.B.1: Существуют механизмы и внешние инструменты упрощения работы с `null` в `Java`: например,
аннотации `@Nullable` и `@NotNull` от разных вендоров. О них будет рассказано позднее в курсе.

N.B.2: Существуют операции в `Java`, которые не могут вернуть `null`: например, вызов оператора
`new` в любой его форме. Также безопасно использование функций, которые никогда не возвращают
`null`. Таким образом, если вы сами написали функцию, которая никогда не возвращает `null`, то
перепроверять её при вызове необязательно.

</details>