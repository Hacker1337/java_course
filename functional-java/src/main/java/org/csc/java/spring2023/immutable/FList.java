package org.csc.java.spring2023.immutable;

import java.util.function.BiFunction;

/**
 * Данный класс моделирует неизменяемый список, похожий на списки из функциональных языков
 * программирования (Functional List).
 * <p>
 * Созданный однажды список не подлежит изменению до самого конца программы. Это удобно, поскольку
 * его можно переиспользовать в нескольких местах сразу, не опасаясь совместных модификаций.
 * <p>
 * Список позволяет узнавать свой размер, получать элементы по индексу, а также имеет два метода
 * {@link FList#foldr} и {@link FList#foldl}, которые позволяют легко и эффективно выполнять над ним
 * различные преобразования.
 * <p>
 * ВАЖНО: Одной из задач является выставление корректных сигнатур у всех методов, в которых
 * используются параметры с дженериками - вам нужно проставить {@code extends} и {@code super} таким
 * образом, чтобы сигнатуры были максимально гибкими.
 */
public sealed interface FList<T> permits Nil, Cons {

  /**
   * Позволяет узнать размер списка.
   * <p>
   * Этот метод должен работать за O(1).
   */
  int size();

  /**
   * Возвращает элемент списка, находящийся по индексу.
   * <p>
   * Этот метод должен работать за O(N).
   */
  T get(int index);

  /**
   * /**
   * <p>
   * Операция правой свертки.
   * </p>
   * <p>
   * Пример: {@code foldr([1, 2, 3, 4], 42, f) == f(1, f(2, f(3, f(4, 42))))}. f в данном случае -
   * какая-то операция (например, сложение).
   * </p>
   * <p>
   * Несколько примеров есть в тестах.
   * </p>
   * <p>
   * Этот метод является package-private, чтобы его нельзя было использовать напрямую. Если вы
   * хотите воспользоваться операцией `foldr`, см. класс `FListUtils`
   * </p>
   */
  <R> R foldr(R zero, BiFunction<? super T, R, ? extends R> folder);

  /**
   * <p>
   * Операция левой свертки.
   * </p>
   * <p>
   * Пример: {@code foldl([1, 2, 3, 4], 42, f) == f(f(f(f(42, 1), 2), 3), 4)}. f в данном случае -
   * какая-то операция (например, сложение).
   * </p>
   * <p>
   * Несколько примеров есть в тестах.
   * </p>
   * <p>
   * Этот метод является package-private, чтобы его нельзя было использовать напрямую. Если вы
   * хотите воспользоваться операцией `foldl`, см. класс `FListUtils`
   * </p>
   */
  <R> R foldl(R zero, BiFunction<R, ? super T, ? extends R> folder);

  /**
   * Должно вернуть строковое представление списка в следующем виде: "FList [a1, a2, a3]", где a1,
   * a2, a3 - элементы списка через запятую.
   * <p>
   * Этот метод должен работать за O(N).
   */
  @Override
  String toString();

  /**
   * Два списка равны, если они имеют одинаковую длину и содержащиеся в них элементы попарно равны.
   * <p>
   * Элементы должны сравниваться с использованием
   * {@link java.util.Objects#equals(Object, Object)}.
   */
  @Override
  boolean equals(Object other);

  /**
   * Хеш код списка напрямую зависит от его содержимого. Воспользуйтесь
   * {@link java.util.Objects#hash}.
   */
  @Override
  int hashCode();
}
